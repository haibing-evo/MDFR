setwd("E:\\xiehb_sync\\F2\\data\\sscrofa11.data")

require(sqldf)

#load the phased data generated by SHAPEIT2
haplotype = read.table("chr1.phased.duohmm.haps")
sample = read.table("chr1.phased.duohmm.sample",skip=2)

f2id = as.data.frame(as.matrix(sample[77:654,2]))

# pedigree saves the family information
# the values are the sample id
#-------------------------------------------------------------------------  
# table format (7 columns):
#-------------------------------------------------------------------------  
#       F2   F1male   F0male   F0female   F1female  F0male  F0female
#     ^^^^   ^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^^^^
#     f2id          family1                       family2
#-------------------------------------------------------------------------  

# -------- It is much safer to use the following code to generate pedigree information
# ---------because the order of F2 and F1/F0 can differ in different variables.
f1father = sqldf("select a.V1,b.V4 from f2id a, sample b where a.V1=b.V2",drv="SQLite")
f1mother = sqldf("select a.V1,b.V5 from f2id a, sample b where a.V1=b.V2",drv="SQLite")
family1 = sqldf("select a.V1,b.V2,b.V4,b.V5 from f1father a, sample b where a.V4=b.V2",drv="SQLite")
family2 = sqldf("select a.V1,b.V2,b.V4,b.V5 from f1mother a, sample b where a.V5=b.V2",drv="SQLite")
pedigree = sqldf("select a.V1,a.V2,a.V4,a.V5,b.V2,b.V4,b.V5 from family1 a,family2 b where a.V1=b.V1",drv="SQLite")


pedigree_tmp = as.data.frame(matrix(as.vector(as.matrix(pedigree)),byrow=T,ncol=1))

allsample = as.vector(sample[[2]])
allsample = as.data.frame(cbind(1:length(allsample),allsample))
allsamplepos = sqldf("select a.V1 from pedigree_tmp b left join allsample a on b.V1 = a.allsample",drv="SQLite")
allsamplepos = as.vector(as.matrix(allsamplepos))

#pedigree_info saves the column # for each individual
pedigree_info = matrix(allsamplepos,byrow=F,nrow=nrow(pedigree))

#pedigree_haps saves the column # for chromosomes in the haplotype (data frame)
pedigree_haps1 = (pedigree_info-1)*2+6 
pedigree_haps2 = (pedigree_info-1)*2+7
pedigree_haps = cbind(pedigree_haps1,pedigree_haps2)[,c(1,8,2,9,3,10,4,11,5,12,6,13,7,14)]

# add SNP coordinates column # to pedigree_haps 
pedigree_haps = cbind(3,pedigree_haps)
pedigree_haps = cbind(1,pedigree_haps)

####################################################################
#  The following code is used to determine the paternal and maternal alleles inherited by F2 individuals
####################################################################

#--------------------------------------------------------
#determine the difference between two haplotypes
# m and n are numbers indicating the column # in dataframe pedigree_haplotype that contains the two haplotypes for comparison
# The score is the number of mismatches between two haplotypes
#--------------------------------------------------------
GetScore = function(m,n)
{
  return(abs(pedigree_haplotype[[m]]-pedigree_haplotype[[n]]))
}

#--------------------------------------------------------
# To figure out which part of the haplotype in a chromosome (x) is inherited from which part of the haplotypes of parental chromosomes y and z.
# The primary role of this function is to identify recombination events inherited by the chromosome x
# The return value is the haplotype of x encoded by y and z
# x, y, z are column # specifying different haplotype saving positions in the data frame for a specific family
#--------------------------------------------------------
StepHap = function(x,y,z,n)
{
  mismatchY = GetScore(x,y)
  mismatchZ = GetScore(x,z)
  
  finalseq = 0
  localsites = n
  
  finalseq=rep(0,localsites)
  lastparent = 0
  lastblockend = 0
  
  while(length(finalseq[finalseq==0])>0)
  {
    vectorY = which(mismatchY[(lastblockend+1):length(mismatchY)]==1)
    vectorZ = which(mismatchZ[(lastblockend+1):length(mismatchZ)]==1)
    
    firstY = min(vectorY) + lastblockend
    firstZ = min(vectorZ) + lastblockend
    firstY
    firstZ
    
    if(is.infinite(firstY) && is.infinite(firstZ)==F)
    {
      finalseq[(lastblockend+1):length(mismatchY)] = y
      break
    }
    if(is.infinite(firstZ) && is.infinite(firstY)==F)
    {
      finalseq[(lastblockend+1):length(mismatchZ)] = z
      break
    }
    if(is.infinite(firstY) && is.infinite(firstZ))
    {
      finalseq[(lastblockend+1):length(mismatchZ)] = lastparent
      break
    }
    
    if(firstY==firstZ)
    {
      if(lastparent>0)
      {
        finalseq[(lastblockend+1):firstY] = lastparent
      }
      else
      {
        finalseq[(lastblockend+1):firstY] = y
      }
      lastblockend = firstY
    } else
    {
      if(firstZ > firstY)
      {
        finalseq[(lastblockend+1):(firstZ-1)] = z
        lastblockend = firstZ - 1
        lastparent = z
      } else
      {
        finalseq[(lastblockend+1):(firstY-1)] = y
        lastblockend = firstY - 1
        lastparent = y
      }
    }
  }
  
  return(finalseq)
}

#--------------------------------------------------------------------
# This function is to correct genotyping errors & crossover errors
# It takes three steps
# the function has four parameters
#--------------------------------------------------------
correcting_haplotype = function(onehap,columnflag,minfraglen,mindiffs)
{
  alleles = unique(onehap)
  
  #step1
  #remove genotyping errors
  if(length(onehap[onehap==alleles[1]])<=3)
  {
    onehap[onehap==alleles[1]] = alleles[2]
    return(onehap)
  }
  if(length(onehap[onehap==alleles[2]])<=3)
  {
    onehap[onehap==alleles[2]] = alleles[1]
    return(onehap)
  }
  
  #step2
  #remove crossover errors with short genomic spans
  finderr=1
  i=1:(length(onehap)-1)
  j=i+1
  while(finderr==1)
  {
    finderr=0
    seps = c(0,which(onehap[i]!=onehap[j]),length(onehap))
    seps
    if(length(seps)>=3)
    {
      frags = cbind(seps[1:(length(seps)-1)]+1,seps[2:length(seps)])
      fraglen = frags[,2]-frags[,1]+1
      shortspanid = which(fraglen<=minfraglen)
      if(length(shortspanid)>0)
      {
        for(k in 1:length(shortspanid))
        {
          finderr=1
          onehap[frags[shortspanid[k],1]:frags[shortspanid[k],2]] = columnflag - onehap[frags[shortspanid[k],1]:frags[shortspanid[k],2]]
        }
      }
    }
  }
  
  #step3
  #remove crossovers with a few informative markers
  seps = c(0,which(onehap[i]!=onehap[j]),length(onehap))
  if(length(seps)>=3)
  {
    frags = cbind(seps[1:(length(seps)-1)]+1,seps[2:length(seps)])
    fraglen = frags[,2]-frags[,1]+1
    hapdiff = pedigree_haplotype[[(columnflag-1)/2]]-pedigree_haplotype[[(columnflag+1)/2]]
    for(k in 1:nrow(frags))
    {
      fragdiff = sum(abs(hapdiff[frags[k,1]:frags[k,2]]))
      if(fragdiff<=mindiffs)
      {
        onehap[frags[k,1]:frags[k,2]] = columnflag - onehap[frags[k,1]:frags[k,2]]
      }
    }
  }
  return(onehap)
}


#--------------------------------------------------------
#   Resolving the genotypes in the haplotypes
#--------------------------------------------------------
# Recode F2 haplotype using F1 haplotypes
for(j in 1:18)
{
	haplotype = read.table(sprintf("chr%d.phased.duohmm.haps",j))
	sample = read.table(sprintf("chr%d.phased.duohmm.sample",j),skip=2)

	F2RecodedByF1 = haplotype
	for(pedigreeid in 1:nrow(f2id))
	{
	  cat(sprintf("pedigreeid=%d\n",pedigreeid))
	  pedigree_haplotype = haplotype[,pedigree_haps[pedigreeid,]]
	  score1 = sum(GetScore(3,5)+GetScore(4,11))
	  score2 = sum(GetScore(3,5)+GetScore(4,12))
	  score3 = sum(GetScore(3,6)+GetScore(4,11))
	  score4 = sum(GetScore(3,6)+GetScore(4,12))
	  score5 = sum(GetScore(4,5)+GetScore(3,11))
	  score6 = sum(GetScore(4,5)+GetScore(3,12))
	  score7 = sum(GetScore(4,6)+GetScore(3,11))
	  score8 = sum(GetScore(4,6)+GetScore(3,12))
	  
	  score = c(score1,score2,score3,score4,score5,score6,score7,score8)
	  score
	  optpos = which(score==min(score))
	  optpos = optpos[1]
	  optpos
	  chrhap1=0
	  chrhap2=0
	  
	  if(optpos<=4)
	  {
		x=3
		y=5
		z=6
		chrhap1 = StepHap(x,y,z,nrow(haplotype))
		x=4
		y=11
		z=12
		chrhap2 = StepHap(x,y,z,nrow(haplotype))
	  } else
	  {
		x=4
		y=5
		z=6
		chrhap1 = StepHap(x,y,z,nrow(haplotype))
		x=3
		y=11
		z=12
		chrhap2 = StepHap(x,y,z,nrow(haplotype))
	  }
	  F2RecodedByF1[,pedigree_haps[pedigreeid,][3]] = correcting_haplotype(chrhap1,11,50,10)
	  F2RecodedByF1[,pedigree_haps[pedigreeid,][4]] = correcting_haplotype(chrhap2,23,50,10)
	}

	#--------------------------------------------------------
	#Save the paternal and maternal alleles in each of the F2
	#The f2inheritance.txt is a SNP-based file 
	#--------------------------------------------------------
	for(pedigreeid in 1:nrow(f2id))
	{
	  x = cbind(f2id[pedigreeid,1],F2RecodedByF1[,c(1,3)],F2RecodedByF1[,pedigree_haps[pedigreeid,][3]], F2RecodedByF1[,pedigree_haps[pedigreeid,][4]])
	  write.table(x, "f2inheritance.txt",append=T,quote=F,row.names=F,col.names=F,sep="\t")
	}
}

#--------------------------------------------------------
#Import the f2inheritance into a MYSQL database
#--------------------------------------------------------
require(RMySQL)
f2inheritance = read.table("f2inheritance.txt", head=F)
names(f2inheritance) = c("f2", "chr", "pos", "f1father", "f1mother")
mysqlserver="127.0.0.1"
mysqlport=3306
mysqldbname="MDFR"
mysqluser="xiehb"
mysqlpassword=""
con<-dbConnect(dbDriver("MySQL"),host=mysqlserver,port=mysqlport,dbname=mysqldbname,user=mysqluser,password=mysqlpassword)

dbWriteTable(con, "f2inheritance", f2inheritance,overwrite = TRUE, row.names = FALSE)
sql = "create index idx1 on f2inheritance(f2, f1father, f1mother)"
ret = dbSendQuery(con, sql)
sql = "create index idx2 on f2inheritance(chr, pos)"
ret = dbSendQuery(con, sql)



#--------------------------------------------------------
#Generate the f2fragmentinheritance from f2inheritance
#This step is to identify genomic fragments that are inherited as a whole
#The paternal and maternal genomes are calculated independently
#The resulting file is f2inheritance.length.txt and a relevant table is f2fragmentinheritance in database
#--------------------------------------------------------
sql=sprintf("select distinct f2 from f2inheritance where chr=1")
result = dbGetQuery(con, sql)
f2all  = result[[1]]

for(chr in c(1:18))
{
  for(f2id in 1:length(f2all))
  {
      f2=f2all[f2id]
      
      sql=sprintf("select * from f2inheritance where chr=%d and f2=%d order by pos",chr,f2)
      result = dbGetQuery(con, sql)
      
      d1 = result$f1mother[-length(result$f1mother)]
      d2 = result$f1mother[-1]
      end = which(d1!=d2)
      start = c(1,end+1)
      end = c(end,length(result$f1mother))
      m = cbind(f2,chr,result[start,3],result[end,3],result[start,5]%%2,'M')
      
      d1 = result$f1father[-length(result$f1father)]
      d2 = result$f1father[-1]
      end = which(d1!=d2)
      start = c(1,end+1)
      end = c(end,length(result$f1father))
      p = cbind(f2,chr,result[start,3],result[end,3],result[start,4]%%2,'P')
      data = rbind(m,p)
      write.table(data,"f2inheritance.length.txt",sep="\t",quote=F,col.names=F,row.names=F,append=T)
  }
}

outval = read.table("f2inheritance.length.txt",head=F)
names(outval)=c("f2","chr","start","end","inheritance","origin")
dbRemoveTable(con,"f2fragmentinheritance")
dbWriteTable(con,"f2fragmentinheritance",outval,append=T,row.names=F)
sql = "create index idx1 on f2fragmentinheritance (inheritance, origin);"
ret = dbSendQuery(con, sql)
sql = "create index idx2 on f2fragmentinheritance (f2, chr, start, end, inheritance, origin);"
ret = dbSendQuery(con, sql)
sql = "create index idx3 on f2fragmentinheritance (chr);"
ret = dbSendQuery(con, sql)




#--------------------------------------------------------
#Generate the f2fragmentinheritance_window.txt and a relevant table f2fragmentinheritance_window
#from the table f2fragmentinheritance
# This step generates the genotypes of 1-Mb sliding windows for each individual
#--------------------------------------------------------
sql = "select f2,chr,floor(start/1000000) as startwin,floor(end/1000000) as endwin,inheritance,origin from f2fragmentinheritance;"
result = dbGetQuery(con, sql)
result[1:10,]

setwd("E:\\xiehb_sync\\F2\\data\\sscrofa11.data")

for(i in 1:nrow(result))
{
  write.table(cbind(result[i,1:2],result[i,3]:result[i,4],result[i,5:6]),"f2fragmentinheritance_window.txt",quote=F,row.names=F,col.names=F,append=T)
}
outval = c()
outval = read.table("f2fragmentinheritance_window.txt",head=F)
names(outval)=c("f2","chr","window","inheritance","origin")
dbRemoveTable(con,"f2fragmentinheritance_window")
dbWriteTable(con,"f2fragmentinheritance_window",outval,append=T,row.names=F)
sql = "create index idx1 on f2fragmentinheritance_window (chr, window);"
ret = dbSendQuery(con, sql)
sql = "delete from f2fragmentinheritance_window where f2%2=1 and chr=23 and origin=\"P\""
ret = dbSendQuery(con, sql)

#--------------------------------------------------------
# There are missing values in f2fragmentinheritance_window due to some exceptions where there are no informative SNPs in some sliding windows.
# The missing values are filled with genotypes of flanking windows.
#--------------------------------------------------------
sql = "select distinct f2 from f2fragmentinheritance_window"
f2 = dbGetQuery(con, sql)
for(i in 1:nrow(f2))
{
  for(j in 1:18)
  {
    sql = sprintf("select window,inheritance from f2fragmentinheritance_window 
                  where f2=%s and chr=%d and origin='P' group by window order by window",f2[i,1],j)
    windowdata = dbGetQuery(con, sql)
    window = as.vector(as.matrix(windowdata[,1]))
    inheritance = as.vector(as.matrix(windowdata[,2]))
    
    misspos = which( (window[-1] - window[-length(window)])!=1)
    misspos
    if(length(misspos)>0)
    {
      print(sprintf("f2=%d chr=%d misspos=%d P",f2[i,1],j,misspos[1]))
      for(x in 1:length(misspos))
      {
        k = misspos[x]
        recpos = floor((window[k+1]+window[k])/2)
        if((window[k]+1)<recpos)
        {
          for(m in (window[k]+1):(recpos-1))
          {
            sql = sprintf("insert into f2fragmentinheritance_window
                    (f2,chr,window,inheritance,origin)
                    values (%s,%d,%d,%d,'P')",f2[i,1],j,m,inheritance[k])
            dbSendQuery(con, sql)
            print(sprintf("%s chr=%d window=%d 'P'",f2[i,1],j,m))
          }
        }
        sql = sprintf("insert into f2fragmentinheritance_window 
                    (f2,chr,window,inheritance,origin)
                    values (%s,%d,%d,%d,'P')",f2[i,1],j,recpos,inheritance[k])
        dbSendQuery(con, sql)
        print(sprintf("%s chr=%d window=%d 'P' recpos1",f2[i,1],j,recpos))
        
        sql = sprintf("insert into f2fragmentinheritance_window 
                    (f2,chr,window,inheritance,origin)
                    values (%s,%d,%d,%d,'P')",f2[i,1],j,recpos,1-inheritance[k])
        dbSendQuery(con, sql)
        print(sprintf("%s chr=%d window=%d 'P' recpos2",f2[i,1],j,recpos))
        if((window[k+1]-1)>recpos)
        {
          for(m in (recpos+1):(window[k+1]-1))
          {
            sql = sprintf("insert into f2fragmentinheritance_window 
                    (f2,chr,window,inheritance,origin)
                    values (%s,%d,%d,%d,'P')",f2[i,1],j,m,inheritance[k+1])
            dbSendQuery(con, sql)
            print(sprintf("%s chr=%d window=%d 'P'",f2[i,1],j,m))
          }
        }        
      }
    }


    sql = sprintf("select window,inheritance from f2fragmentinheritance_window 
                  where f2=%s and chr=%d and origin='M' group by window order by window",f2[i,1],j)
    windowdata = dbGetQuery(con, sql)
    window = as.vector(as.matrix(windowdata[,1]))
    inheritance = as.vector(as.matrix(windowdata[,2]))
    misspos = which( (window[-1] - window[-length(window)])!=1)
    misspos
    if(length(misspos)>0)
    {
      print(sprintf("f2=%d chr=%d misspos=%d M",f2[i,1],j,misspos[1]))
      for(x in 1:length(misspos))
      {
        k = misspos[x]
        recpos = floor((window[k+1]+window[k])/2)
        if((window[k]+1)<recpos)
        {
          for(m in (window[k]+1):(recpos-1))
          {
            sql = sprintf("insert into f2fragmentinheritance_window 
                    (f2,chr,window,inheritance,origin)
                    values (%s,%d,%d,%d,'M')",f2[i,1],j,m,inheritance[k])
            dbSendQuery(con, sql)
            print(sprintf("%s chr=%d window=%d 'M'",f2[i,1],j,m))
          }
        }
        sql = sprintf("insert into f2fragmentinheritance_window 
                    (f2,chr,window,inheritance,origin)
                    values (%s,%d,%d,%d,'M')",f2[i,1],j,recpos,inheritance[k])
        dbSendQuery(con, sql)
        print(sprintf("%s chr=%d window=%d 'M' recpos1",f2[i,1],j,recpos))
        
        sql = sprintf("insert into f2fragmentinheritance_window 
                    (f2,chr,window,inheritance,origin)
                    values (%s,%d,%d,%d,'M')",f2[i,1],j,recpos,1-inheritance[k])
        dbSendQuery(con, sql)
        print(sprintf("%s chr=%d window=%d 'M' recpos2",f2[i,1],j,recpos))
        
        if((window[k+1]-1)>recpos)
        {
          for(m in (recpos+1):(window[k+1]-1))
          {
            sql = sprintf("insert into f2fragmentinheritance_window 
                    (f2,chr,window,inheritance,origin)
                    values (%s,%d,%d,%d,'M')",f2[i,1],j,m,inheritance[k+1])
            dbSendQuery(con, sql)
            print(sprintf("%s chr=%d window=%d 'M'",f2[i,1],j,m))
          }
        }        
      }
    }   
  }
}

#------------------------------------------------------------------------------------------------------------
# The table f2fragmentinheritance_window contains sliding windows on which some of F2 carry recombination breakpoints.
# The recombination breaks within a window will cause the genotype of the window not unique.
# The samples should be removed on such windows in the f2fragmentinheritance_window table
# The resulting table is f2fragmentinheritance_window_without_recombination
#------------------------------------------------------------------------------------------------------------
sql="create table f2fragmentinheritance_window_without_recombination select * from f2fragmentinheritance_window"
dbGetQuery(con, sql)

sql="create index idx1 on f2fragmentinheritance_window_without_recombination (f2,chr,window,origin,inheritance)"
dbGetQuery(con, sql)
sql="create index idx2 on f2fragmentinheritance_window_without_recombination (chr,window,origin,inheritance)"
dbGetQuery(con, sql)

sql="SELECT f2,chr,window FROM f2fragmentinheritance_window group by f2,chr,window,origin having count(distinct inheritance)>1"
recombination_window = dbGetQuery(con, sql)
for(i in 1:nrow(recombination_window))
{
  sql=sprintf("delete from f2fragmentinheritance_window_without_recombination where f2=%d and chr=%d and window=%d",
              recombination_window[i,1],recombination_window[i,2],recombination_window[i,3])
  dbGetQuery(con, sql)
}


#------------------------------------------------------------------------------------------------------------
# Convert f2fragmentinheritance_window_without_recombination into f2fragmentinheritance_window_without_recombination_PM
# for subsequent analysis
#------------------------------------------------------------------------------------------------------------
sql = "create table f2fragmentinheritance_window_without_recombination_PM
SELECT a.f2,a.chr,a.window,a.inheritance as paternalinheritance,b.inheritance as maternalinheritance
FROM f2fragmentinheritance_window_without_recombination a,f2fragmentinheritance_window_without_recombination b
where a.chr=b.chr and a.f2=b.f2 and a.window=b.window and a.origin=\"P\" and b.origin=\"M\"
order by f2,chr,window"
dbSendQuery(con, sql)
